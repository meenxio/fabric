// Code generated by protoc-gen-go. DO NOT EDIT.
// source: discovery/protocol.proto

/*
Package discovery is a generated protocol buffer package.

It is generated from these files:
	discovery/protocol.proto

It has these top-level messages:
	SignedRequest
	Request
	Response
	AuthInfo
	Query
	QueryResult
	ConfigQuery
	ConfigResult
	PeerMembershipQuery
	PeerMembershipResult
	ChaincodeQuery
	ChaincodeQueryResult
	EndorsementDescriptor
	Layout
	Peers
	Peer
	Error
	Endpoints
	Endpoint
*/
package discovery

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import gossip "github.com/hyperledger/fabric/protos/gossip"
import msp "github.com/hyperledger/fabric/protos/msp"
import _ "github.com/hyperledger/fabric/protos/msp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// SignedRequest contains a serialized Request in the payload field
// and a signature.
// The identity that is used to verify the signature
// can be extracted from the authentication field of type AuthInfo
// in the Request itself after deserializing it.
type SignedRequest struct {
	Payload   []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SignedRequest) Reset()                    { *m = SignedRequest{} }
func (m *SignedRequest) String() string            { return proto.CompactTextString(m) }
func (*SignedRequest) ProtoMessage()               {}
func (*SignedRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SignedRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *SignedRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Request contains authentication info about the client that sent the request
// and the queries it wishes to query the service
type Request struct {
	// authentication contains information that the service uses to check
	// the client's eligibility for the queries.
	Authentication *AuthInfo `protobuf:"bytes,1,opt,name=authentication" json:"authentication,omitempty"`
	// queries
	Queries []*Query `protobuf:"bytes,2,rep,name=queries" json:"queries,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Request) GetAuthentication() *AuthInfo {
	if m != nil {
		return m.Authentication
	}
	return nil
}

func (m *Request) GetQueries() []*Query {
	if m != nil {
		return m.Queries
	}
	return nil
}

type Response struct {
	// The results are returned in the same order of the queries
	Results []*QueryResult `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Response) GetResults() []*QueryResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// AuthInfo aggregates authentication information that the server uses
// to authenticate the client
type AuthInfo struct {
	// This is the identity of the client that is used to verify the signature
	// on the SignedRequest's payload.
	// It is a msp.SerializedIdentity in bytes form
	ClientIdentity []byte `protobuf:"bytes,1,opt,name=client_identity,json=clientIdentity,proto3" json:"client_identity,omitempty"`
	// This is the hash of the client's TLS cert.
	// When the network is running with TLS, clients that don't include a certificate
	// will be denied access to the service.
	// Since the Request is encapsulated with a SignedRequest (which is signed),
	// this binds the TLS session to the enrollement identity of the client and
	// therefore both authenticates the client to the server,
	// and also prevents the server from relaying the request message to another server.
	ClientTlsCertHash []byte `protobuf:"bytes,2,opt,name=client_tls_cert_hash,json=clientTlsCertHash,proto3" json:"client_tls_cert_hash,omitempty"`
}

func (m *AuthInfo) Reset()                    { *m = AuthInfo{} }
func (m *AuthInfo) String() string            { return proto.CompactTextString(m) }
func (*AuthInfo) ProtoMessage()               {}
func (*AuthInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AuthInfo) GetClientIdentity() []byte {
	if m != nil {
		return m.ClientIdentity
	}
	return nil
}

func (m *AuthInfo) GetClientTlsCertHash() []byte {
	if m != nil {
		return m.ClientTlsCertHash
	}
	return nil
}

// Query asks for information in the context of a specific channel
type Query struct {
	Channel string `protobuf:"bytes,1,opt,name=channel" json:"channel,omitempty"`
	// Types that are valid to be assigned to Query:
	//	*Query_ConfigQuery
	//	*Query_PeerQuery
	//	*Query_CcQuery
	Query isQuery_Query `protobuf_oneof:"query"`
}

func (m *Query) Reset()                    { *m = Query{} }
func (m *Query) String() string            { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()               {}
func (*Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isQuery_Query interface {
	isQuery_Query()
}

type Query_ConfigQuery struct {
	ConfigQuery *ConfigQuery `protobuf:"bytes,2,opt,name=configQuery,oneof"`
}
type Query_PeerQuery struct {
	PeerQuery *PeerMembershipQuery `protobuf:"bytes,3,opt,name=peerQuery,oneof"`
}
type Query_CcQuery struct {
	CcQuery *ChaincodeQuery `protobuf:"bytes,4,opt,name=ccQuery,oneof"`
}

func (*Query_ConfigQuery) isQuery_Query() {}
func (*Query_PeerQuery) isQuery_Query()   {}
func (*Query_CcQuery) isQuery_Query()     {}

func (m *Query) GetQuery() isQuery_Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *Query) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Query) GetConfigQuery() *ConfigQuery {
	if x, ok := m.GetQuery().(*Query_ConfigQuery); ok {
		return x.ConfigQuery
	}
	return nil
}

func (m *Query) GetPeerQuery() *PeerMembershipQuery {
	if x, ok := m.GetQuery().(*Query_PeerQuery); ok {
		return x.PeerQuery
	}
	return nil
}

func (m *Query) GetCcQuery() *ChaincodeQuery {
	if x, ok := m.GetQuery().(*Query_CcQuery); ok {
		return x.CcQuery
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Query) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Query_OneofMarshaler, _Query_OneofUnmarshaler, _Query_OneofSizer, []interface{}{
		(*Query_ConfigQuery)(nil),
		(*Query_PeerQuery)(nil),
		(*Query_CcQuery)(nil),
	}
}

func _Query_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Query)
	// query
	switch x := m.Query.(type) {
	case *Query_ConfigQuery:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConfigQuery); err != nil {
			return err
		}
	case *Query_PeerQuery:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PeerQuery); err != nil {
			return err
		}
	case *Query_CcQuery:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CcQuery); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Query.Query has unexpected type %T", x)
	}
	return nil
}

func _Query_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Query)
	switch tag {
	case 2: // query.configQuery
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConfigQuery)
		err := b.DecodeMessage(msg)
		m.Query = &Query_ConfigQuery{msg}
		return true, err
	case 3: // query.peerQuery
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PeerMembershipQuery)
		err := b.DecodeMessage(msg)
		m.Query = &Query_PeerQuery{msg}
		return true, err
	case 4: // query.ccQuery
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChaincodeQuery)
		err := b.DecodeMessage(msg)
		m.Query = &Query_CcQuery{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Query_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Query)
	// query
	switch x := m.Query.(type) {
	case *Query_ConfigQuery:
		s := proto.Size(x.ConfigQuery)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Query_PeerQuery:
		s := proto.Size(x.PeerQuery)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Query_CcQuery:
		s := proto.Size(x.CcQuery)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// QueryResult contains a result for a given Query.
// The corresponding Query can be inferred by the index of the QueryResult from
// its enclosing Response message.
// QueryResults are ordered in the same order as the Queries are ordered in their enclosing Request.
type QueryResult struct {
	// Types that are valid to be assigned to Result:
	//	*QueryResult_Error
	//	*QueryResult_ConfigResult
	//	*QueryResult_CcQueryRes
	//	*QueryResult_Members
	Result isQueryResult_Result `protobuf_oneof:"result"`
}

func (m *QueryResult) Reset()                    { *m = QueryResult{} }
func (m *QueryResult) String() string            { return proto.CompactTextString(m) }
func (*QueryResult) ProtoMessage()               {}
func (*QueryResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isQueryResult_Result interface {
	isQueryResult_Result()
}

type QueryResult_Error struct {
	Error *Error `protobuf:"bytes,1,opt,name=error,oneof"`
}
type QueryResult_ConfigResult struct {
	ConfigResult *ConfigResult `protobuf:"bytes,2,opt,name=configResult,oneof"`
}
type QueryResult_CcQueryRes struct {
	CcQueryRes *ChaincodeQueryResult `protobuf:"bytes,3,opt,name=ccQueryRes,oneof"`
}
type QueryResult_Members struct {
	Members *PeerMembershipResult `protobuf:"bytes,4,opt,name=members,oneof"`
}

func (*QueryResult_Error) isQueryResult_Result()        {}
func (*QueryResult_ConfigResult) isQueryResult_Result() {}
func (*QueryResult_CcQueryRes) isQueryResult_Result()   {}
func (*QueryResult_Members) isQueryResult_Result()      {}

func (m *QueryResult) GetResult() isQueryResult_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *QueryResult) GetError() *Error {
	if x, ok := m.GetResult().(*QueryResult_Error); ok {
		return x.Error
	}
	return nil
}

func (m *QueryResult) GetConfigResult() *ConfigResult {
	if x, ok := m.GetResult().(*QueryResult_ConfigResult); ok {
		return x.ConfigResult
	}
	return nil
}

func (m *QueryResult) GetCcQueryRes() *ChaincodeQueryResult {
	if x, ok := m.GetResult().(*QueryResult_CcQueryRes); ok {
		return x.CcQueryRes
	}
	return nil
}

func (m *QueryResult) GetMembers() *PeerMembershipResult {
	if x, ok := m.GetResult().(*QueryResult_Members); ok {
		return x.Members
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QueryResult) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QueryResult_OneofMarshaler, _QueryResult_OneofUnmarshaler, _QueryResult_OneofSizer, []interface{}{
		(*QueryResult_Error)(nil),
		(*QueryResult_ConfigResult)(nil),
		(*QueryResult_CcQueryRes)(nil),
		(*QueryResult_Members)(nil),
	}
}

func _QueryResult_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QueryResult)
	// result
	switch x := m.Result.(type) {
	case *QueryResult_Error:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *QueryResult_ConfigResult:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConfigResult); err != nil {
			return err
		}
	case *QueryResult_CcQueryRes:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CcQueryRes); err != nil {
			return err
		}
	case *QueryResult_Members:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Members); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("QueryResult.Result has unexpected type %T", x)
	}
	return nil
}

func _QueryResult_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QueryResult)
	switch tag {
	case 1: // result.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_Error{msg}
		return true, err
	case 2: // result.configResult
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConfigResult)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_ConfigResult{msg}
		return true, err
	case 3: // result.ccQueryRes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChaincodeQueryResult)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_CcQueryRes{msg}
		return true, err
	case 4: // result.members
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PeerMembershipResult)
		err := b.DecodeMessage(msg)
		m.Result = &QueryResult_Members{msg}
		return true, err
	default:
		return false, nil
	}
}

func _QueryResult_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QueryResult)
	// result
	switch x := m.Result.(type) {
	case *QueryResult_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryResult_ConfigResult:
		s := proto.Size(x.ConfigResult)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryResult_CcQueryRes:
		s := proto.Size(x.CcQueryRes)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *QueryResult_Members:
		s := proto.Size(x.Members)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ConfigQuery requests a ConfigResult
type ConfigQuery struct {
}

func (m *ConfigQuery) Reset()                    { *m = ConfigQuery{} }
func (m *ConfigQuery) String() string            { return proto.CompactTextString(m) }
func (*ConfigQuery) ProtoMessage()               {}
func (*ConfigQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type ConfigResult struct {
	// msps is a map from MSP_ID to FabricMSPConfig
	Msps map[string]*msp.FabricMSPConfig `protobuf:"bytes,1,rep,name=msps" json:"msps,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// orderers is a map from MSP_ID to endpoint lists of orderers
	Orderers map[string]*Endpoints `protobuf:"bytes,2,rep,name=orderers" json:"orderers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ConfigResult) Reset()                    { *m = ConfigResult{} }
func (m *ConfigResult) String() string            { return proto.CompactTextString(m) }
func (*ConfigResult) ProtoMessage()               {}
func (*ConfigResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ConfigResult) GetMsps() map[string]*msp.FabricMSPConfig {
	if m != nil {
		return m.Msps
	}
	return nil
}

func (m *ConfigResult) GetOrderers() map[string]*Endpoints {
	if m != nil {
		return m.Orderers
	}
	return nil
}

// PeerMembershipQuery requests PeerMembershipResult
type PeerMembershipQuery struct {
}

func (m *PeerMembershipQuery) Reset()                    { *m = PeerMembershipQuery{} }
func (m *PeerMembershipQuery) String() string            { return proto.CompactTextString(m) }
func (*PeerMembershipQuery) ProtoMessage()               {}
func (*PeerMembershipQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// PeerMembershipResult contains peers mapped by their organizations (MSP_ID)
type PeerMembershipResult struct {
	PeersByOrg map[string]*Peers `protobuf:"bytes,1,rep,name=peers_by_org,json=peersByOrg" json:"peers_by_org,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PeerMembershipResult) Reset()                    { *m = PeerMembershipResult{} }
func (m *PeerMembershipResult) String() string            { return proto.CompactTextString(m) }
func (*PeerMembershipResult) ProtoMessage()               {}
func (*PeerMembershipResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *PeerMembershipResult) GetPeersByOrg() map[string]*Peers {
	if m != nil {
		return m.PeersByOrg
	}
	return nil
}

// ChaincodeQuery requests ChaincodeQueryResults for a given
// list of chaincodes
type ChaincodeQuery struct {
	Chaincodes []string `protobuf:"bytes,1,rep,name=chaincodes" json:"chaincodes,omitempty"`
}

func (m *ChaincodeQuery) Reset()                    { *m = ChaincodeQuery{} }
func (m *ChaincodeQuery) String() string            { return proto.CompactTextString(m) }
func (*ChaincodeQuery) ProtoMessage()               {}
func (*ChaincodeQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ChaincodeQuery) GetChaincodes() []string {
	if m != nil {
		return m.Chaincodes
	}
	return nil
}

// ChaincodeQueryResult contains EndorsementDescriptors for
// chaincodes
type ChaincodeQueryResult struct {
	Content []*EndorsementDescriptor `protobuf:"bytes,1,rep,name=content" json:"content,omitempty"`
}

func (m *ChaincodeQueryResult) Reset()                    { *m = ChaincodeQueryResult{} }
func (m *ChaincodeQueryResult) String() string            { return proto.CompactTextString(m) }
func (*ChaincodeQueryResult) ProtoMessage()               {}
func (*ChaincodeQueryResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ChaincodeQueryResult) GetContent() []*EndorsementDescriptor {
	if m != nil {
		return m.Content
	}
	return nil
}

// EndorsementDescriptor contains information about which peers can be used
// to request endorsement from, such that the endorsement policy would be fulfilled.
// Here is how to compute a set of peers to ask an endorsement from, given an EndorsementDescriptor:
// Let e: G --> P be the endorsers_by_groups field that maps a group to a set of peers.
// Note that applying e on a group g yields a set of peers.
// 1) Select a layout l: G --> N out of the layouts given.
//    l is the quantities_by_group field of a Layout, and it maps a group to an integer.
// 2) R = {}  (an empty set of peers)
// 3) For each group g in the layout l, compute n = l(g)
//    3.1) Denote P_g as a set of n random peers {p0, p1, ... p_n} selected from e(g)
//    3.2) R = R U P_g  (add P_g to R)
// 4) The set of peers R is the peers the client needs to request endorsements from
type EndorsementDescriptor struct {
	Chaincode string `protobuf:"bytes,1,opt,name=chaincode" json:"chaincode,omitempty"`
	// Specifies the endorsers, separated to groups.
	EndorsersByGroups map[string]*Peers `protobuf:"bytes,2,rep,name=endorsers_by_groups,json=endorsersByGroups" json:"endorsers_by_groups,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Specifies options of fulfulling the endorsement policy.
	// Each option lists the group names, and the amount of signatures needed
	// from each group.
	Layouts []*Layout `protobuf:"bytes,3,rep,name=layouts" json:"layouts,omitempty"`
}

func (m *EndorsementDescriptor) Reset()                    { *m = EndorsementDescriptor{} }
func (m *EndorsementDescriptor) String() string            { return proto.CompactTextString(m) }
func (*EndorsementDescriptor) ProtoMessage()               {}
func (*EndorsementDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *EndorsementDescriptor) GetChaincode() string {
	if m != nil {
		return m.Chaincode
	}
	return ""
}

func (m *EndorsementDescriptor) GetEndorsersByGroups() map[string]*Peers {
	if m != nil {
		return m.EndorsersByGroups
	}
	return nil
}

func (m *EndorsementDescriptor) GetLayouts() []*Layout {
	if m != nil {
		return m.Layouts
	}
	return nil
}

// Layout contains a mapping from a group name to number of peers
// that are needed for fulfilling an endorsement policy
type Layout struct {
	// Specifies how many non repeated signatures of each group
	// are needed for endorsement
	QuantitiesByGroup map[string]uint32 `protobuf:"bytes,1,rep,name=quantities_by_group,json=quantitiesByGroup" json:"quantities_by_group,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *Layout) Reset()                    { *m = Layout{} }
func (m *Layout) String() string            { return proto.CompactTextString(m) }
func (*Layout) ProtoMessage()               {}
func (*Layout) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Layout) GetQuantitiesByGroup() map[string]uint32 {
	if m != nil {
		return m.QuantitiesByGroup
	}
	return nil
}

// Peers contains a list of Peer(s)
type Peers struct {
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *Peers) Reset()                    { *m = Peers{} }
func (m *Peers) String() string            { return proto.CompactTextString(m) }
func (*Peers) ProtoMessage()               {}
func (*Peers) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Peers) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

// Peer contains information about the peer such as its channel specific
// state, and membership information.
type Peer struct {
	// This is an Envelope of a GossipMessage with a gossip.StateInfo message
	StateInfo *gossip.Envelope `protobuf:"bytes,1,opt,name=state_info,json=stateInfo" json:"state_info,omitempty"`
	// This is an Envelope of a GossipMessage with a gossip.AliveMessage message
	MembershipInfo *gossip.Envelope `protobuf:"bytes,2,opt,name=membership_info,json=membershipInfo" json:"membership_info,omitempty"`
	// This is the msp.SerializedIdentity of the peer, represented in bytes.
	Identity []byte `protobuf:"bytes,3,opt,name=identity,proto3" json:"identity,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Peer) GetStateInfo() *gossip.Envelope {
	if m != nil {
		return m.StateInfo
	}
	return nil
}

func (m *Peer) GetMembershipInfo() *gossip.Envelope {
	if m != nil {
		return m.MembershipInfo
	}
	return nil
}

func (m *Peer) GetIdentity() []byte {
	if m != nil {
		return m.Identity
	}
	return nil
}

// Error denotes that something went wrong and contains the error message
type Error struct {
	Content string `protobuf:"bytes,1,opt,name=content" json:"content,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Error) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// Endpoints is a list of Endpoint(s)
type Endpoints struct {
	Endpoint []*Endpoint `protobuf:"bytes,1,rep,name=endpoint" json:"endpoint,omitempty"`
}

func (m *Endpoints) Reset()                    { *m = Endpoints{} }
func (m *Endpoints) String() string            { return proto.CompactTextString(m) }
func (*Endpoints) ProtoMessage()               {}
func (*Endpoints) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Endpoints) GetEndpoint() []*Endpoint {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

// Endpoint is a combination of a host and a port
type Endpoint struct {
	Host string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Port uint32 `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
}

func (m *Endpoint) Reset()                    { *m = Endpoint{} }
func (m *Endpoint) String() string            { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()               {}
func (*Endpoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Endpoint) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Endpoint) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func init() {
	proto.RegisterType((*SignedRequest)(nil), "discovery.SignedRequest")
	proto.RegisterType((*Request)(nil), "discovery.Request")
	proto.RegisterType((*Response)(nil), "discovery.Response")
	proto.RegisterType((*AuthInfo)(nil), "discovery.AuthInfo")
	proto.RegisterType((*Query)(nil), "discovery.Query")
	proto.RegisterType((*QueryResult)(nil), "discovery.QueryResult")
	proto.RegisterType((*ConfigQuery)(nil), "discovery.ConfigQuery")
	proto.RegisterType((*ConfigResult)(nil), "discovery.ConfigResult")
	proto.RegisterType((*PeerMembershipQuery)(nil), "discovery.PeerMembershipQuery")
	proto.RegisterType((*PeerMembershipResult)(nil), "discovery.PeerMembershipResult")
	proto.RegisterType((*ChaincodeQuery)(nil), "discovery.ChaincodeQuery")
	proto.RegisterType((*ChaincodeQueryResult)(nil), "discovery.ChaincodeQueryResult")
	proto.RegisterType((*EndorsementDescriptor)(nil), "discovery.EndorsementDescriptor")
	proto.RegisterType((*Layout)(nil), "discovery.Layout")
	proto.RegisterType((*Peers)(nil), "discovery.Peers")
	proto.RegisterType((*Peer)(nil), "discovery.Peer")
	proto.RegisterType((*Error)(nil), "discovery.Error")
	proto.RegisterType((*Endpoints)(nil), "discovery.Endpoints")
	proto.RegisterType((*Endpoint)(nil), "discovery.Endpoint")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Discovery service

type DiscoveryClient interface {
	// Discover receives a signed request, and returns a response.
	Discover(ctx context.Context, in *SignedRequest, opts ...grpc.CallOption) (*Response, error)
}

type discoveryClient struct {
	cc *grpc.ClientConn
}

func NewDiscoveryClient(cc *grpc.ClientConn) DiscoveryClient {
	return &discoveryClient{cc}
}

func (c *discoveryClient) Discover(ctx context.Context, in *SignedRequest, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/discovery.Discovery/Discover", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Discovery service

type DiscoveryServer interface {
	// Discover receives a signed request, and returns a response.
	Discover(context.Context, *SignedRequest) (*Response, error)
}

func RegisterDiscoveryServer(s *grpc.Server, srv DiscoveryServer) {
	s.RegisterService(&_Discovery_serviceDesc, srv)
}

func _Discovery_Discover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscoveryServer).Discover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/discovery.Discovery/Discover",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscoveryServer).Discover(ctx, req.(*SignedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Discovery_serviceDesc = grpc.ServiceDesc{
	ServiceName: "discovery.Discovery",
	HandlerType: (*DiscoveryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Discover",
			Handler:    _Discovery_Discover_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "discovery/protocol.proto",
}

func init() { proto.RegisterFile("discovery/protocol.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1019 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x1b, 0x6e, 0xd2, 0xa6, 0x49, 0xde, 0xfe, 0x4f, 0xb3, 0xfd, 0xf2, 0x45, 0x68, 0xb7, 0x6b, 0x69,
	0xa1, 0x5a, 0x24, 0xbb, 0x2a, 0x5a, 0x01, 0xed, 0x82, 0xd4, 0x6e, 0xcb, 0x66, 0x25, 0xaa, 0x6e,
	0xbd, 0x08, 0x21, 0x4e, 0x22, 0xc7, 0x79, 0x6b, 0x5b, 0xd8, 0x1e, 0x77, 0x66, 0x5c, 0xc9, 0x67,
	0x5c, 0x01, 0x37, 0xc1, 0x09, 0xe2, 0x12, 0xb8, 0x17, 0xee, 0x05, 0x79, 0x7e, 0x1c, 0x27, 0x4d,
	0xb4, 0x48, 0x9c, 0x79, 0x9e, 0xf7, 0x79, 0xde, 0x7f, 0x7b, 0x0c, 0xfd, 0x49, 0xc4, 0x7d, 0xfa,
	0x80, 0xac, 0x70, 0x32, 0x46, 0x05, 0xf5, 0x69, 0x6c, 0xcb, 0x07, 0xd2, 0xad, 0x2c, 0x83, 0x5e,
	0x40, 0x39, 0x8f, 0x32, 0x27, 0x41, 0xce, 0xbd, 0x00, 0x15, 0x61, 0xd0, 0x4b, 0x78, 0xe6, 0x24,
	0x3c, 0x1b, 0xf9, 0x34, 0xbd, 0x8b, 0x82, 0x3a, 0x1a, 0x4d, 0x30, 0x15, 0x91, 0x88, 0x90, 0x2b,
	0xd4, 0x7a, 0x0b, 0x5b, 0x1f, 0xa2, 0x20, 0xc5, 0x89, 0x8b, 0xf7, 0x39, 0x72, 0x41, 0xfa, 0xd0,
	0xce, 0xbc, 0x22, 0xa6, 0xde, 0xa4, 0xdf, 0x38, 0x6c, 0x1c, 0x6d, 0xba, 0xe6, 0x48, 0x3e, 0x81,
	0x2e, 0x8f, 0x82, 0xd4, 0x13, 0x39, 0xc3, 0x7e, 0x53, 0xda, 0xa6, 0x80, 0xc5, 0xa0, 0x6d, 0x5c,
	0x9c, 0xc1, 0xb6, 0x97, 0x8b, 0xb0, 0x8c, 0xe4, 0x7b, 0x22, 0xa2, 0xa9, 0xf4, 0xb4, 0x71, 0xb2,
	0x6f, 0x57, 0x99, 0xdb, 0xe7, 0xb9, 0x08, 0xdf, 0xa5, 0x77, 0xd4, 0x9d, 0xa3, 0x92, 0x97, 0xd0,
	0xbe, 0xcf, 0x91, 0x45, 0xc8, 0xfb, 0xcd, 0xc3, 0xd5, 0xa3, 0x8d, 0x93, 0xdd, 0x9a, 0xea, 0x36,
	0x47, 0x56, 0xb8, 0x86, 0x60, 0xbd, 0x86, 0x8e, 0x8b, 0x3c, 0xa3, 0x29, 0x47, 0x72, 0x0c, 0x6d,
	0x86, 0x3c, 0x8f, 0x05, 0xef, 0x37, 0xa4, 0xee, 0xe0, 0x91, 0x4e, 0x9a, 0x5d, 0x43, 0xb3, 0x26,
	0xd0, 0x31, 0x59, 0x90, 0xcf, 0x60, 0xc7, 0x8f, 0x23, 0x4c, 0xc5, 0x48, 0x77, 0xa8, 0xd0, 0xd5,
	0x6f, 0x2b, 0xf8, 0x9d, 0x46, 0x89, 0x03, 0x3d, 0x4d, 0x14, 0x31, 0x1f, 0xf9, 0xc8, 0xc4, 0x28,
	0xf4, 0x78, 0xa8, 0xfb, 0xb1, 0xa7, 0x6c, 0x3f, 0xc4, 0xfc, 0x0d, 0x32, 0x31, 0xf4, 0x78, 0x68,
	0xfd, 0xdd, 0x80, 0x96, 0x0c, 0x5f, 0x76, 0xd6, 0x0f, 0xbd, 0x34, 0xc5, 0x58, 0xfa, 0xee, 0xba,
	0xe6, 0x48, 0x4e, 0x61, 0x43, 0x8d, 0x4a, 0x12, 0xa5, 0xaf, 0xd9, 0xfc, 0xdf, 0x4c, 0xad, 0xc3,
	0x15, 0xb7, 0x4e, 0x26, 0xdf, 0x42, 0x37, 0x43, 0x64, 0x4a, 0xb9, 0x2a, 0x95, 0x4f, 0x6b, 0xca,
	0xf7, 0x88, 0xec, 0x1a, 0x93, 0x31, 0x32, 0x1e, 0x46, 0x99, 0xf1, 0x30, 0x95, 0x90, 0x57, 0xd0,
	0xf6, 0x7d, 0xa5, 0x5e, 0x93, 0xea, 0xff, 0xd7, 0xe3, 0x86, 0x5e, 0x94, 0xfa, 0x74, 0x82, 0x46,
	0x68, 0xb8, 0x17, 0x6d, 0x68, 0x95, 0x53, 0x28, 0xac, 0x5f, 0x9b, 0xb0, 0x51, 0x6b, 0x2f, 0x39,
	0x82, 0x16, 0x32, 0x46, 0x99, 0x9e, 0x79, 0x7d, 0x7a, 0x57, 0x25, 0x3e, 0x5c, 0x71, 0x15, 0x81,
	0x7c, 0x03, 0x9b, 0xaa, 0x10, 0xa5, 0xd4, 0x65, 0xff, 0xef, 0x51, 0xd9, 0xca, 0x3c, 0x5c, 0x71,
	0x67, 0xe8, 0xe4, 0x1c, 0x40, 0x27, 0xe3, 0x22, 0xd7, 0x95, 0x3f, 0x5b, 0x9a, 0x7b, 0xe5, 0xa4,
	0x26, 0x22, 0x67, 0xd0, 0x4e, 0x54, 0x6f, 0x74, 0xed, 0xcf, 0x96, 0x76, 0xae, 0xd2, 0x1b, 0xc5,
	0x45, 0x07, 0xd6, 0xd5, 0x26, 0x59, 0x5b, 0xb0, 0x51, 0x1b, 0x90, 0xf5, 0x67, 0x13, 0x36, 0xeb,
	0x99, 0x93, 0x57, 0xb0, 0x96, 0xf0, 0xcc, 0xec, 0xe5, 0xf3, 0x25, 0x05, 0xda, 0xd7, 0x3c, 0xe3,
	0x57, 0xa9, 0x60, 0x85, 0x2b, 0xe9, 0xe4, 0x1c, 0x3a, 0x94, 0x4d, 0x90, 0x95, 0xe9, 0xa9, 0x57,
	0xe1, 0xc5, 0x32, 0xe9, 0x8d, 0xe6, 0x29, 0x79, 0x25, 0x1b, 0x5c, 0x43, 0xb7, 0xf2, 0x4a, 0x76,
	0x61, 0xf5, 0x17, 0x2c, 0xf4, 0xee, 0x95, 0x8f, 0xe4, 0x25, 0xb4, 0x1e, 0xbc, 0x38, 0x47, 0xdd,
	0xfa, 0x9e, 0x9d, 0xf0, 0xcc, 0xfe, 0xce, 0x1b, 0xb3, 0xc8, 0xbf, 0xfe, 0xf0, 0x5e, 0x47, 0x50,
	0x94, 0xd3, 0xe6, 0x57, 0x8d, 0xc1, 0x2d, 0x6c, 0xcd, 0x44, 0xfa, 0x37, 0x2e, 0x6b, 0xe3, 0x4f,
	0x27, 0x19, 0x8d, 0x52, 0xc1, 0x6b, 0x2e, 0xad, 0x27, 0xb0, 0xbf, 0x60, 0x45, 0xad, 0xbf, 0x1a,
	0xd0, 0x5b, 0x34, 0x00, 0x72, 0x0b, 0x9b, 0xe5, 0xee, 0xf2, 0xd1, 0xb8, 0x18, 0x51, 0x16, 0xe8,
	0x9e, 0x3a, 0x1f, 0x99, 0x9b, 0x04, 0xf9, 0x45, 0x71, 0xc3, 0x02, 0xd5, 0x22, 0xc8, 0x2a, 0x60,
	0x70, 0x03, 0x3b, 0x73, 0xe6, 0x05, 0x75, 0x7d, 0x3a, 0x5b, 0xd7, 0xee, 0x5c, 0xc0, 0x99, 0x9a,
	0x8e, 0x61, 0x7b, 0x76, 0xf9, 0xc8, 0x53, 0x00, 0xdf, 0x20, 0x6a, 0x0f, 0xba, 0x6e, 0x0d, 0xb1,
	0x5c, 0xe8, 0x2d, 0x5a, 0x57, 0x72, 0x0a, 0x6d, 0x9f, 0xa6, 0x02, 0x53, 0xa1, 0x0b, 0x3d, 0x9c,
	0xed, 0x27, 0x65, 0x1c, 0x13, 0x4c, 0xc5, 0x25, 0x72, 0x9f, 0x45, 0x99, 0xa0, 0xcc, 0x35, 0x02,
	0xeb, 0xf7, 0x26, 0x3c, 0x59, 0x48, 0x29, 0x3f, 0xe4, 0x55, 0x6c, 0x5d, 0xe3, 0x14, 0x20, 0x01,
	0xec, 0xa3, 0x92, 0xa9, 0x2e, 0x07, 0x8c, 0xe6, 0x99, 0xd9, 0xc0, 0x2f, 0x3f, 0x16, 0xdf, 0xa0,
	0x65, 0x3b, 0xdf, 0x4a, 0xa5, 0x6a, 0xf8, 0x1e, 0xce, 0xe3, 0xe4, 0x73, 0x68, 0xc7, 0x5e, 0x41,
	0x73, 0x51, 0xbe, 0xbd, 0xa5, 0xf3, 0xbd, 0x9a, 0xf3, 0xef, 0xa5, 0xc5, 0x35, 0x8c, 0xc1, 0x8f,
	0x70, 0xb0, 0xd8, 0xf3, 0x7f, 0x9c, 0xd5, 0x1f, 0x0d, 0x58, 0x57, 0xb1, 0xc8, 0x4f, 0xb0, 0x7f,
	0x9f, 0x7b, 0xfa, 0x7a, 0xac, 0x2a, 0xd7, 0x8d, 0x3f, 0x7a, 0x94, 0x9b, 0x7d, 0x5b, 0x91, 0x75,
	0x42, 0xba, 0xd2, 0xfb, 0x79, 0x7c, 0x70, 0x09, 0x07, 0x8b, 0xc9, 0x0b, 0x92, 0xef, 0xd5, 0x93,
	0xdf, 0xaa, 0xa7, 0x6a, 0x43, 0x4b, 0xa6, 0x4f, 0x5e, 0x40, 0x4b, 0xae, 0xaf, 0x4e, 0x6d, 0x67,
	0xae, 0x3e, 0x57, 0x59, 0xad, 0xdf, 0x1a, 0xb0, 0x56, 0x9e, 0x89, 0x03, 0xc0, 0x85, 0x27, 0x70,
	0x14, 0xa5, 0x77, 0xb4, 0xfa, 0x2e, 0xab, 0x5f, 0x07, 0xfb, 0x2a, 0x7d, 0xc0, 0x98, 0x66, 0xe8,
	0x76, 0x25, 0x47, 0xde, 0x86, 0x5f, 0xc3, 0x4e, 0x52, 0xbd, 0x41, 0x4a, 0xd5, 0x5c, 0xa2, 0xda,
	0x9e, 0x12, 0xa5, 0x74, 0x00, 0x9d, 0xea, 0x06, 0x5d, 0x95, 0x77, 0x62, 0x75, 0xb6, 0x9e, 0x43,
	0x4b, 0x5e, 0x01, 0xf2, 0x26, 0xac, 0xd6, 0x5a, 0xdd, 0x84, 0x7a, 0x69, 0x5f, 0x43, 0xb7, 0xfa,
	0x4c, 0x10, 0x07, 0x3a, 0xa8, 0x0f, 0xba, 0xd4, 0xfd, 0x05, 0x9f, 0x13, 0xb7, 0x22, 0x59, 0x27,
	0xd0, 0x31, 0x28, 0x21, 0xb0, 0x16, 0x52, 0x6e, 0x02, 0xc8, 0xe7, 0x12, 0xcb, 0x28, 0x13, 0xba,
	0xb5, 0xf2, 0xf9, 0x64, 0x08, 0xdd, 0x4b, 0xe3, 0x93, 0x9c, 0x41, 0xc7, 0x1c, 0x48, 0xbf, 0x16,
	0x6b, 0xe6, 0x17, 0x69, 0x50, 0xcf, 0xc2, 0xfc, 0x7f, 0x58, 0x2b, 0x17, 0xc7, 0x3f, 0xdb, 0x41,
	0x24, 0xc2, 0x7c, 0x6c, 0xfb, 0x34, 0x71, 0xc2, 0x22, 0x43, 0x16, 0xe3, 0x24, 0x40, 0xe6, 0xdc,
	0xc9, 0x4f, 0xaa, 0xfa, 0x8f, 0xe3, 0x4e, 0x25, 0x1e, 0xaf, 0x4b, 0xe4, 0x8b, 0x7f, 0x02, 0x00,
	0x00, 0xff, 0xff, 0x44, 0x33, 0xd9, 0xf5, 0xec, 0x09, 0x00, 0x00,
}
